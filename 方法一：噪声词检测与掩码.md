📋 实施方案 - 分步骤进行
---
第一步：创建噪声检测数据集类
文件：bases.py
任务：新增一个数据集类，支持加载干净文本和噪声文本对
具体修改：
```
# 在 ImageTextMLMDataset 类后面添加新类

class ImageTextNoiseDetectionDataset(Dataset):
    """
    图文数据集类（用于噪声检测训练）
    返回：图像 + 干净文本 + 噪声文本 + 噪声标签
    """
```
需要实现的功能：
1. 加载图像
2. 加载干净caption和噪声caption（从JSON文件中）
3. 对比两个caption生成噪声标签（0/1数组）
4. 生成属性词mask（只在属性词位置计算loss）
---
第二步：添加噪声检测损失函数
文件：objectives.py

任务：新增噪声检测的损失函数

具体修改：

```
# 在文件末尾添加

def compute_noise_detection(noise_logits, noise_labels, attribute_mask):
    """
    噪声检测二分类损失
    Args:
        noise_logits: (B, L, 2) - 每个token的分类logits
        noise_labels: (B, L) - 0=干净, 1=噪声
        attribute_mask: (B, L) - 1=属性词位置, 0=其他词
    """
```
---
第三步：修改IRRA模型架构
文件：build.py

任务：

保留cross-modal transformer
移除MLM head
新增噪声检测head
修改forward逻辑
具体修改位置：

在__init__中：注释掉mlm_head，添加noise_detection_head
在forward中：修改返回的特征和损失
---
第四步：修改训练配置
文件：options.py

任务：添加新的命令行参数

具体修改：

```
# 添加噪声检测相关参数
parser.add_argument("--noise_detection", default=False, action='store_true')
parser.add_argument("--noise_loss_weight", type=float, default=1.0)
parser.add_argument("--noisy_train_json", default="", help="path to noisy training json")
```
---
第五步：修改数据加载器
文件：build.py

任务：根据是否使用噪声检测，选择不同的数据集类

具体修改：在build_dataloader函数中添加条件分支

---
第六步：修改训练流程
文件：processor.py

任务：在训练循环中添加噪声检测损失的计算
---
第七步：实现测试时的噪声掩码
文件：新建 processor/noise_masking.py

任务：实现测试时的噪声检测和掩码逻辑

---
第八步：修改测试脚本
文件：test.py

任务：调用噪声掩码功能进行推理


# 当前完成的：
训练阶段：datasets/base根据干净噪声文本的差异构造出noisy_label，以及新构造了一个训练类；build可以根据新添加的noisy_detection使用刚刚构建的数据集；model/build新添加了二分类头，输入噪声文本，在对应的图像中融合特征，把次特征丢入二分类头查看他对噪声的预测，接着计算损失，需要和我们标准的label进行比对。
测试阶段：修改evaluator，先用噪声文本全局特征尝试着匹配，找到几个前k个最有可能的，取他们的均值，接着和噪声文本组成融合特征，丢入训练好的二分类头，判断哪些可能是添加过噪声的，通过一系列噪声词数量的限制，选出最终注入噪声的位置，将这些地方标注为mask，处理好后再次去匹配寻找。

第一阶段修改——11.11晚
训练阶段有预热，并且使用干净文本进行主任务而不是上一次噪声文本，会调整noisy_loss的权重，数据集返回clean_cap用于一致性损失，就是让噪声文本和干净文本尽量靠近，降低模型对“属性替换”噪声的敏感度；测试阶段加入了噪声过滤（但这里还需完善），以及多个策略，包含选取上下文的策略和软掩码/硬掩码，训练采用sdm+itc+id

第一阶段修改——11.12晚上
再次加入MLM损失任务，训练采用sdm+mlm+id，并且加大attribute_mask范围，计算损失时同时考虑正负样本的影响，而不是像之前那样只考虑正样本，放大噪声的影响